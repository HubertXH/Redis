#### Mysql-唯一索引
当需要获取锁的时候可以向数据库中插入一条数据，当释放锁的时候将插入的数据删除。
- 锁没有失效时间，如果释放锁失败，那就该锁就形成死锁，导致其他线程无法拿到该锁。
- 非阻塞锁，如果插入失败，无法进行重试队列。
- 该锁为非重入锁

#### Redis分布式锁
##### setnx expire getset
setnx key value (set if not exits) 将key的值设置为value若key已经存在着什么都不做，若key不存在则进行set。 
1、A线程设置key，value，并设置过期时间为T1，返回true，获取锁
2、B线程使用get获取key的超市时间，T1判断是否超时，若没超时则返回false。
3、T1超时，B线程使用getset命令获取超时时间T并将T与T1进行对比，若T==T1则获取锁，若T!=T1怎说明有其他线程已经获取了锁。
4、执行完业务逻辑后进行锁释放。

#### RedLock算法：
1、获取当前时间
2、从N个相互独立的redis客户端获取锁
3、从客户端获取锁，当且仅当从大多数客户端获取锁的时间小于锁的有效时间，则认为获取锁成功。
4、重新计算锁的有效时间，原锁的有效时间减去获取锁消耗的时间。
5、执行业务逻辑，后删除所有客户端的锁。


#### zookeeper实现分布式锁

- 临时节点：客户端创建一个临时节点，在客户端会话结束或者超时之后zookeeper删除该节点。
- 永久节点：节点创建之后就不会被删除。
- 有序节点：例如当前节点的父节点为/lock则在创建子节点的时候zookeeper会根据当前子节点的数目添加相应的整数序号，如果创建的是第一个自节点则
节点的名称为：node-00000001,下一个创建的节点名称为：node-00000002,一次类推。
- 时间监听：在读取数据的时候我们同时可以对节点进行监听，当节点有数据或结构的变化的时，zookeeper会通知客户端。现在有的监听事件有：节点的创建，
删除，数据的修改，子节点的变动。

###### zookeeper实现分布式锁的流程
1、首先在目录下创建一个临时且有序的节点。
2、客户端获取目录下自节点列表，判断自己的节点是否为该目录下最小的节点，若是则获取锁成功，否则监听该节点，获取变更通知后重复该步骤。
3、执行业务代码，删除节点。
